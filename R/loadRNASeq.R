#' Load bcbio RNA-Seq Data
#'
#' Simply point to the final upload directory output by
#' [bcbio](https://bcbio-nextgen.readthedocs.io/), and this function will take
#' care of the rest. It automatically imports RNA-seq counts, metadata, and
#' program versions used.
#'
#' @author Michael Steinbaugh, Lorena Pantano
#'
#' @importFrom basejump annotable camel readYAML
#' @importFrom bcbioBase prepareSummarizedExperiment readDataVersions
#'   readLogFile readProgramVersions readSampleMetadataFile sampleYAMLMetadata
#'   sampleYAMLMetrics
#' @importFrom DESeq2 DESeq DESeqDataSetFromTximport DESeqTransform rlog
#'  varianceStabilizingTransformation
#' @importFrom dplyr mutate_if pull
#' @importFrom magrittr set_colnames
#' @importFrom stats formula
#' @importFrom stringr str_match
#' @importFrom tibble column_to_rownames rownames_to_column
#'
#' @param uploadDir Path to final upload directory. This path is set when
#'   running `bcbio_nextgen -w template`.
#' @param interestingGroups Character vector of interesting groups. First entry
#'   is used for plot colors during quality control (QC) analysis. Entire vector
#'   is used for PCA and heatmap QC functions.
#' @param sampleMetadataFile *Optional.* Custom metadata file containing
#'   sample information. Otherwise defaults to sample metadata saved in the YAML
#'   file. Remote URLs are supported.
#' @param annotable *Optional.* User-defined gene annotations (a.k.a.
#'   "annotable"), which will be slotted into [rowData()]. Typically this should
#'   be left undefined. By default, the function will automatically generate an
#'   annotable from the annotations available on Ensembl. If set `NULL`, then
#'   [rowData()] inside the resulting [bcbioRNASeq] object will be left empty.
#'   This is recommended for projects dealing with genes or transcripts that are
#'   poorly annotated.
#' @param organism *Optional.* Organism name. Use the full latin name (e.g.
#'   "Homo sapiens"), since this will be input downstream to
#'   AnnotationHub/ensembldb. If set, this genome must be supported on Ensembl.
#'   Normally this can be left `NULL`, and the function will attempt to detect
#'   the organism automatically using [detectOrganism()].
#' @param ensemblVersion *Optional.* Ensembl release version. If `NULL`,
#'   defaults to current release, and does not typically need to be
#'   user-defined. This parameter can be useful for matching Ensembl annotations
#'   against an outdated bcbio annotation build.
#' @param genomeBuild *Optional.* Genome build. Normally this can be left `NULL`
#'   and the build will be detected from the bcbio run data. This can be set
#'   manually (e.g. "hg19" for the older *Homo sapiens* reference genome). Note
#'   that this must match the genome build identifier on Ensembl for annotations
#'   to download correctly.
#' @param transformationLimit Maximum number of samples to calculate
#'   [DESeq2::rlog()] and [DESeq2::varianceStabilizingTransformation()] matrix.
#'   It is not generally recommended to change this value. For large datasets,
#'   DESeq2 will take a really long time applying variance stabilization. See
#'   Details.
#' @param design DESeq2 design formula. Empty by default. Can be updated after
#'   initial data loading using the [design()] function.
#' @param ... Additional arguments, slotted into the [metadata()] accessor.
#'
#' @note When working in RStudio, we recommend connecting to the bcbio-nextgen
#'   run directory as a remote connection over
#'   [sshfs](https://github.com/osxfuse/osxfuse/wiki/SSHFS).
#'
#' @details
#' When number of samples is bigger than `transformationLimit`, `rlog` and `vst`
#' counts will not be slotted into `assays()`. In this case, we recommend
#' visualization using the `tmm` counts generated by edgeR.
#'
#' @return [bcbioRNASeq].
#' @export
#'
#' @examples
#' uploadDir <- system.file(
#'     file.path("extdata", "bcbio"),
#'     package = "bcbioRNASeq")
#'
#' bcb <- loadRNASeq(uploadDir, interestingGroups = "group")
#' print(bcb)
#'
#' # Load without gene annotations
#' # Advanced use only! Not generally recommended.
#' bcb <- loadRNASeq(uploadDir, annotable = NULL)
#' print(bcb)
#' rowData(bcb)
loadRNASeq <- function(
    uploadDir,
    interestingGroups = "sampleName",
    sampleMetadataFile = NULL,
    annotable = TRUE,
    organism = NULL,
    ensemblVersion = NULL,
    genomeBuild = NULL,
    transformationLimit = 50L,
    design = NULL,
    ...) {
    assert_all_are_dirs(uploadDir)
    assert_is_any_of(sampleMetadataFile, c("character", "NULL"))
    if (is.character(sampleMetadataFile)) {
        assert_is_a_string(sampleMetadataFile)
        assert_are_existing_files(sampleMetadataFile)
    }
    assert_is_character(interestingGroups)
    assert_is_any_of(annotable, c("data.frame", "logical", "NULL"))
    assert_is_a_string_or_null(organism)
    # TODO assert_is_implicit_integer_scalar_or_null
    assert_is_numeric_scalar_or_null(ensemblVersion)
    if (is.numeric(ensemblVersion)) {
        assert_is_implicit_integer(ensemblVersion)
    }
    assert_is_a_string_or_null(genomeBuild)
    assert_is_numeric(transformationLimit)  # Allow Inf
    assert_is_scalar(transformationLimit)
    assert_is_any_of(design, c("formula", "NULL"))

    # Directory paths ==========================================================
    uploadDir <- normalizePath(uploadDir)
    projectDir <- dir(
        uploadDir,
        pattern = projectDirPattern,
        full.names = FALSE,
        recursive = FALSE)
    assert_is_a_string(projectDir)
    inform(projectDir)
    match <- str_match(projectDir, projectDirPattern)
    runDate <- as.Date(match[[2L]])
    template <- match[[3L]]
    projectDir <- file.path(uploadDir, projectDir)
    assert_all_are_dirs(projectDir)
    sampleDirs <- .sampleDirs(uploadDir)
    assert_all_are_dirs(sampleDirs)

    # Sequencing lanes =========================================================
    lanePattern <- "_L(\\d{3})"
    if (any(grepl(x = sampleDirs, pattern = lanePattern))) {
        lanes <- str_match(names(sampleDirs), lanePattern) %>%
            .[, 2L] %>%
            unique() %>%
            length()
        inform(paste(
            lanes, "sequencing lane detected", "(technical replicates)"
        ))
    } else {
        lanes <- 1L
    }
    assert_is_integer(lanes)
    assert_is_scalar(lanes)

    # Project summary YAML =====================================================
    yamlFile <- file.path(projectDir, "project-summary.yaml")
    assert_all_are_existing_files(yamlFile)
    yaml <- readYAML(yamlFile)
    assert_is_list(yaml)

    # Sample metadata ==========================================================
    if (is_a_string(sampleMetadataFile)) {
        sampleMetadataFile <- normalizePath(sampleMetadataFile)
        sampleMetadata <- readSampleMetadataFile(
            sampleMetadataFile,
            lanes = lanes)
    } else {
        sampleMetadata <- sampleYAMLMetadata(yaml)
    }
    assert_are_set_equal(sampleMetadata[["sampleID"]], names(sampleDirs))

    # Interesting groups =======================================================
    interestingGroups <- camel(interestingGroups)
    assert_is_subset(interestingGroups, colnames(sampleMetadata))

    # Subset sample directories by metadata ====================================
    if (length(sampleMetadata[["sampleID"]]) < length(sampleDirs)) {
        inform("Loading a subset of samples, defined by the metadata file")
        allSamples <- FALSE
        sampleDirs <- sampleDirs %>%
            .[names(sampleDirs) %in% sampleMetadata[["sampleID"]]]
        inform(paste(length(sampleDirs), "samples matched by metadata"))
    } else {
        allSamples <- TRUE
    }

    # Genome ===================================================================
    # Genome build
    if (!is_a_string(genomeBuild)) {
        # Detect from the bcbio project summary YAML
        genomeBuild <- yaml %>%
            .[["samples"]] %>%
            .[[1L]] %>%
            .[["genome_build"]]
    }
    assert_is_a_string(genomeBuild)
    # Organism
    if (is.null(organism) && is_a_string(genomeBuild)) {
        inform("Detecting organism from genome build")
        organism <- detectOrganism(genomeBuild)
    }
    assert_is_a_string(organism)
    inform(paste("Genome:", organism, paste0("(", genomeBuild, ")")))

    # Gene and transcript annotations ==========================================
    if (isTRUE(annotable) && is_a_string(organism)) {
        annotable <- annotable(
            organism,
            genomeBuild = genomeBuild,
            release = ensemblVersion)
    } else if (is.data.frame(annotable)) {
        annotable <- annotable(annotable)
    } else {
        warn("Loading run without gene annotable (not recommended)")
        annotable <- NULL
    }
    tx2gene <- .tx2gene(
        projectDir,
        organism = organism,
        release = ensemblVersion)

    # Sample metrics ===========================================================
    # Note that sample metrics used for QC plots are not currently generated
    # when using fast RNA-seq workflow. This depends upon MultiQC and aligned
    # counts generated with STAR.
    inform("Reading sample metrics")
    metrics <- sampleYAMLMetrics(yaml)
    assert_is_data.frame(metrics)

    # bcbio-nextgen run information ============================================
    inform("Reading bcbio run information")
    dataVersions <- readDataVersions(
        file = file.path(projectDir, "data_versions.csv")
    )
    assert_is_tbl_df(dataVersions)
    # TODO Rename to `programVersions`?
    programs <- readProgramVersions(
        file.path(projectDir, "programs.txt")
    )
    assert_is_tbl_df(programs)
    bcbioLog <- readLogFile(
        file.path(projectDir, "bcbio-nextgen.log")
    )
    # Allowing NULL here for minimal example
    assert_is_any_of(bcbioLog, c("character", "NULL"))
    bcbioCommandsLog <- readLogFile(
        file.path(projectDir, "bcbio-nextgen-commands.log")
    )
    # Allowing NULL here for minimal example
    assert_is_any_of(bcbioCommandsLog, c("character", "NULL"))

    # tximport =================================================================
    txi <- .tximport(sampleDirs, tx2gene = tx2gene)
    assert_is_list(txi)
    rawCounts <- txi[["counts"]]
    assert_is_matrix(rawCounts)
    tmm <- tmm(rawCounts)
    tpm <- txi[["abundance"]]
    assert_is_matrix(tpm)

    # colData ==================================================================
    # This step is necessary for samples have been sanitized with
    # `make.names()`, which can cause samples that are now prefixed with `X` to
    # become out of order in the rows. This will cause the
    # `DESeqDataSetFromTximport` call below to error out because of a
    # `txi$counts` colnames / colData rownames mismatch.
    colData <- sampleMetadata %>%
        as.data.frame() %>%
        .[colnames(rawCounts), , drop = FALSE] %>%
        rownames_to_column() %>%
        mutate_if(is.factor, droplevels) %>%
        column_to_rownames() %>%
        as("DataFrame")

    # DESeqDataSet =============================================================
    inform("Generating internal DESeqDataSet")
    if (!is.formula(design)) {
        design <- formula(~1)  # nolint
    }
    dds <- DESeqDataSetFromTximport(
        txi = txi,
        colData = colData,
        design = design)
    # Suppressing warnings here for empty design formula
    dds <- suppressWarnings(DESeq(dds))
    normalizedCounts <- counts(dds, normalized = TRUE)

    # Variance stabilizing transformations =====================================
    if (nrow(sampleMetadata) > transformationLimit) {
        warn(paste(
            "Dataset contains many samples.",
            "Skipping DESeq2 variance stabilization."
            ))
        rlog <- NULL
        vst <- NULL
    } else {
        inform("Performing rlog transformation")
        rlog <- rlog(dds)
        inform("Performing variance stabilizing transformation")
        vst <- varianceStabilizingTransformation(dds)
    }

    # STAR/featureCounts aligned counts matrix =================================
    # Aligned counts, used for summary metrics. Not generated for fast RNA-seq.
    featureCountsFile <- file.path(projectDir, "combined.counts")
    if (file.exists(featureCountsFile)) {
        inform("Reading STAR featureCounts aligned counts")
        featureCounts <- read_tsv(featureCountsFile) %>%
            as.data.frame() %>%
            # Sanitize sampleIDs in colnames into valid names
            set_colnames(
                gsub(
                    x = make.names(colnames(.), unique = TRUE),
                    pattern = "\\.",
                    replacement = "_")
            ) %>%
            column_to_rownames("id") %>%
            as.matrix()
        if (!identical(colnames(rawCounts), colnames(featureCounts))) {
            # Look for column name mismatch and attempt fix.
            # This is an error fix for the current bcb example dataset.
            # Safe to remove in a future update.
            # Subset columns by matching STAR sample name in metrics.
            featureCounts <- featureCounts %>%
                .[, gsub(x = make.names(pull(metrics, "name"), unique = TRUE),
                        pattern = "\\.",
                        replacement = "_"), drop = FALSE] %>%
                # Ensure column names match tximport
                set_colnames(colnames(rawCounts))
        }
    } else {
        featureCounts <- NULL
    }

    # Metadata =================================================================
    metadata <- list(
        version = packageVersion,
        uploadDir = uploadDir,
        sampleDirs = sampleDirs,
        projectDir = projectDir,
        template = template,
        runDate = runDate,
        interestingGroups = interestingGroups,
        organism = organism,
        genomeBuild = genomeBuild,
        ensemblVersion = ensemblVersion,
        annotable = annotable,
        tx2gene = tx2gene,
        lanes = lanes,
        yaml = yaml,
        metrics = metrics,
        sampleMetadataFile = sampleMetadataFile,
        dataVersions = dataVersions,
        programs = programs,
        bcbioLog = bcbioLog,
        bcbioCommandsLog = bcbioCommandsLog,
        allSamples = allSamples,
        design = design,
        transformationLimit = transformationLimit)
    # Add user-defined custom metadata, if specified
    dots <- list(...)
    if (length(dots) > 0L) {
        metadata <- c(metadata, dots)
    }

    # Return ===================================================================
    # TODO Consider storing DESeqDataSet inside the SummarizedExperiment
    se <- prepareSummarizedExperiment(
        assays = list(
            raw = rawCounts,
            normalized = normalizedCounts,
            tpm = tpm,
            tmm = tmm,
            rlog = rlog,
            vst = vst),
        rowData = annotable,
        colData = colData,
        metadata = metadata
    )
    bcbio <- SimpleList(
        tximport = txi,
        DESeqDataSet = dds,
        featureCounts = featureCounts)
    new("bcbioRNASeq", se, bcbio = bcbio)
}
