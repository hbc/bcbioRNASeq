#' @inherit bcbioRNASeq-class title description
#'
#' @details
#' Automatically imports RNA-seq counts, metadata, and the program versions used
#' from a [bcbio][] RNA-seq run. Simply point to the final upload directory
#' generated by bcbio, and this generator function will take care of the rest.
#'
#' [bcbio]: https://bcbio-nextgen.readthedocs.io
#'
#' @section Sample metadata:
#'
#' When loading a bcbio RNA-seq run, the sample metadata will be imported
#' automatically from the `project-summary.yaml` file in the final upload
#' directory. If you notice any typos in your metadata after completing the run,
#' these can be corrected by editing the YAML file.
#'
#' Alternatively, you can pass in a sample metadata file into the
#' [bcbioRNASeq()] function call using the `sampleMetadataFile` argument. This
#' requires either a CSV or Excel spreadsheet.
#'
#' The samples in the bcbio run must map to the `description` column. The values
#' provided in `description` must be unique. These values will be sanitized into
#' syntactically valid names (see [`make.names`][base::make.names] for more
#' information), and assigned as the column names of the `bcbioRNASeq` object.
#' The original values are stored as the `sampleName` column in `colData`, and
#' are used for all plotting functions. Do not attempt to set a `sampleID`
#' column, as this is used internally by the package.
#'
#' Here is a minimal example of a properly formatted sample metadata file:
#'
#' \tabular{ll}{
#'     description \tab genotype\cr
#'     sample1 \tab wildtype\cr
#'     sample2 \tab knockout\cr
#'     sample3 \tab wildtype\cr
#'     sample4 \tab knockout
#' }
#'
#' @section Valid names:
#'
#' R is strict about values that are considered valid for use in
#' [`names()`][base::names] and [`dimnames()`][base::dimnames] (i.e.
#' [`rownames()`][base::rownames] and [`colnames()`][base::colnames]).
#' Non-alphanumeric characters, spaces, and **dashes** are not valid. Use either
#' underscores or periods in place of dashes when working in R. Also note that
#' names should **not begin with a number**, and will be prefixed with an `X`
#' when sanitized. Consult the documentation in the
#' [`make.names()`][base::make.names] function for more information. We strongly
#' recommend adhering to these conventions when labeling samples, to help avoid
#' unexpected downstream behavior in R due to [`dimnames()`][base::dimnames]
#' mismatches.
#'
#' @section Genome annotations:
#'
#' [bcbioRNASeq()] provides support for automatic import of genome annotations,
#' which internally get processed into genomic ranges (`GRanges`) and are
#' slotted into the [`rowRanges()`][SummarizedExperiment::rowRanges] of the
#' object. Currently, we offer support for (1) [Ensembl][] genome annotations
#' from [AnnotationHub][] via [ensembldb][] (*recommended*); or (2) direct
#' import from a GTF/GFF file using [rtracklayer][].
#'
#' [ensembldb][] requires the `organism` and `ensemblRelease` arguments to be
#' defined. When both of these are set, `bcbioRNASeq` will attempt to
#' download and use the pre-built [Ensembl][] genome annotations from
#' [AnnotationHub][]. This method is preferred over direct loading of a GTF/GFF
#' file because the [AnnotationHub][] annotations contain additional rich
#' metadata not defined in a GFF file, specifically `description` and `entrezID`
#' values.
#'
#' Alternatively, if you are working with a non-standard or poorly annotated
#' genome that isn't available on [AnnotationHub][], we provide fall back
#' support for loading the genome annotations directly from the GTF file used by
#' the bcbio RNA-seq pipeline. This should be fully automatic for an R session
#' active on the same server used to run [bcbio][].
#'
#' Example bcbio GTF path: `genomes/Hsapiens/hg38/rnaseq/ref-transcripts.gtf`.
#'
#' In the event that you are working from a remote environment that doesn't
#' have file system access to the [bcbio][] `genomes` directory, we provide
#' additional fall back support for importing genome annotations from a GTF/GFF
#' directly with the `gffFile` argument.
#'
#' Internally, genome annotations are imported via the [basejump][] package,
#' specifically with either of these functions:
#'
#' - [basejump::makeGRangesFromEnsembl()].
#' - [basejump::makeGRangesFromGFF()].
#'
#' [AnnotationHub]: https://bioconductor.org/packages/AnnotationHub/
#' [basejump]: https://steinbaugh.com/basejump/
#' [bcbio]: https://bcbio-nextgen.readthedocs.io/
#' [Ensembl]: https://ensembl.org/
#' [ensembldb]: https://bioconductor.org/packages/ensembldb/
#' [rtracklayer]: https://bioconductor.org/packages/rtracklayer/
#'
#' @section Genome build:
#'
#' Ensure that the organism and genome build used with bcio match correctly here
#' in the function call. In particular, for the legacy *Homo sapiens*
#' GRCh37/hg19 genome build, ensure that `genomeBuild = "GRCh37"`. Otherwise,
#' the genomic ranges set in [`rowRanges()`][SummarizedExperiment::rowRanges]
#' will mismatch. It is recommended for current projects that GRCh38/hg38 is
#' used in place of GRCh37/hg19 if possible.
#'
#' @section DESeq2:
#'
#' DESeq2 is run automatically when [bcbioRNASeq()] is called, unless `fast =
#' TRUE` is set. Internally, this automatically slots normalized counts into
#' [`assays()`][SummarizedExperiment::assays], and generates variance-stabilized
#' counts.
#'
#' @section Remote connections:
#'
#' When working on a local machine, it is possible to load bcbio run data over a
#' remote connection using [sshfs][]. When loading a large number of samples, it
#' is preferable to call [bcbioRNASeq()] directly in R on the remote server, if
#' possible.
#'
#' [sshfs]: https://github.com/osxfuse/osxfuse/wiki/SSHFS
#'
#' @author Michael Steinbaugh, Lorena Pantano, Rory Kirchner, Victor Barrera
#' @note Updated 2020-01-20.
#' @export
#'
#' @inheritParams basejump::makeSummarizedExperiment
#' @inheritParams acidroxygen::params
#' @param level `character(1)`.
#'   Import counts at gene level ("`genes`"; *default*) or transcript level
#'   ("`transcripts`"; *advanced use*). Only tximport-compatible callers (e.g.
#'   salmon, kallisto, sailfish) can be loaded at transcript level. Aligned
#'   counts from featureCounts-compatible callers (e.g. STAR, HISAT2) can only
#'   be loaded at gene level.
#' @param caller `character(1)`.
#'   Expression caller:
#'
#'   - `"salmon"` (*default*): [Salmon][] alignment-free, quasi-mapped counts.
#'   - `"kallisto"`: [Kallisto][] alignment-free, pseudo-aligned counts.
#'   - `"sailfish"`: [Sailfish][] alignment-free, lightweight counts.
#'   - `"star"`: [STAR][] (Spliced Transcripts Alignment to a Reference)
#'      aligned counts.
#'   - `"hisat2"`: [HISAT2][] (Hierarchical Indexing for Spliced Alignment of
#'     Transcripts) graph-based aligned counts.
#'
#'   [HISAT2]: https://ccb.jhu.edu/software/hisat2/
#'   [Kallisto]: https://pachterlab.github.io/kallisto/
#'   [Sailfish]: http://www.cs.cmu.edu/~ckingsf/software/sailfish/
#'   [Salmon]: https://combine-lab.github.io/salmon/
#'   [STAR]: https://github.com/alexdobin/STAR/
#' @param countsFromAbundance `character(1)`.
#'   Whether to generate estimated counts using abundance estimates
#'   (*recommended by default*). `lengthScaledTPM` is a suitable default, and
#'   counts are scaled using the average transcript length over samples and then
#'   the library size. Refer to [tximport::tximport()] for more information on
#'   this parameter, but it should only ever be changed when loading some
#'   datasets at transcript level (e.g. for DTU analsyis).
#' @param fast `logical(1)`.
#'   Fast mode. Skip internal DESeq2 transformations.
#'
#' @return `bcbioRNASeq`.
#'
#' @seealso
#' - `.S4methods(class = "bcbioRNASeq")`.
#' - `SummarizedExperiment::SummarizedExperiment()`.
#' - `methods::initialize()`.
#' - `methods::validObject()`.
#' - `BiocGenerics::updateObject()`.
#'
#' @examples
#' uploadDir <- system.file("extdata/bcbio", package = "bcbioRNASeq")
#'
#' ## Gene level.
#' object <- bcbioRNASeq(
#'     uploadDir = uploadDir,
#'     level = "genes",
#'     caller = "salmon",
#'     organism = "Mus musculus",
#'     ensemblRelease = 87L
#' )
#' print(object)
#'
#' ## Transcript level.
#' object <- bcbioRNASeq(
#'     uploadDir = uploadDir,
#'     level = "transcripts",
#'     caller = "salmon",
#'     organism = "Mus musculus",
#'     ensemblRelease = 87L
#' )
#' print(object)
#'
#' ## Fast mode.
#' object <- bcbioRNASeq(uploadDir = uploadDir, fast = TRUE)
bcbioRNASeq <- function(
    uploadDir,
    level = c("genes", "transcripts"),
    caller = c("salmon", "kallisto", "sailfish", "star", "hisat2"),
    samples = NULL,
    censorSamples = NULL,
    sampleMetadataFile = NULL,
    organism = NULL,
    genomeBuild = NULL,
    ensemblRelease = NULL,
    gffFile = NULL,
    transgeneNames = NULL,
    spikeNames = NULL,
    countsFromAbundance = "lengthScaledTPM",
    interestingGroups = "sampleName",
    fast = FALSE,
    ...
) {
    ## Legacy arguments --------------------------------------------------------
    ## nocov start
    call <- match.call()
    ## annotable
    if ("annotable" %in% names(call)) {
        stop("'annotable' is defunct. Consider using 'gffFile' instead.")
    }
    ## ensemblVersion
    if ("ensemblVersion" %in% names(call)) {
        stop("Use 'ensemblRelease' instead of 'ensemblVersion'.")
    }
    ## transformationLimit
    if ("transformationLimit" %in% names(call)) {
        stop("'transformationLimit' is defunct.")
    }
    ## rlog
    if ("rlog" %in% names(call)) {
        stop("'rlog' is defunct in favor of 'fast' argument.")
    }
    ## vst
    if ("vst" %in% names(call)) {
        stop("'vst' is defunct in favor of 'fast' argument.")
    }
    ## Error on unsupported arguments.
    assert(isSubset(
        x = setdiff(names(call), ""),
        y = names(formals())
    ))
    rm(call)
    ## nocov end

    ## Assert checks -----------------------------------------------------------
    assert(isADirectory(uploadDir))
    level <- match.arg(level)
    caller <- match.arg(caller)
    if (identical(level, "transcripts")) {
        assert(isSubset(caller, .tximportCallers))
    }
    assert(
        isAny(samples, classes = c("character", "NULL")),
        isAny(censorSamples, classes = c("character", "NULL")),
        isString(sampleMetadataFile, nullOK = TRUE),
        isString(organism, nullOK = TRUE),
        isString(genomeBuild, nullOK = TRUE),
        isInt(ensemblRelease, nullOK = TRUE),
        isAny(transgeneNames, classes = c("character", "NULL")),
        isAny(spikeNames, classes = c("character", "NULL")),
        isString(gffFile, nullOK = TRUE),
        isCharacter(interestingGroups),
        isFlag(fast)
    )
    if (isString(gffFile)) {
        assert(isAFile(gffFile) || containsAURL(gffFile))
    }
    ## Don't allow AnnotationHub formals when specifying GFF file.
    if (!is.null(gffFile)) {
        assert(
            is.null(genomeBuild),
            is.null(ensemblRelease)
        )
    }
    ## Organism is required when we're defining the genome.
    if (
        !is.null(genomeBuild) ||
        !is.null(ensemblRelease) ||
        !is.null(gffFile)
    ) {
        assert(isString(organism))
    }
    match.arg(
        arg = countsFromAbundance,
        choices = eval(formals(tximport)[["countsFromAbundance"]])
    )

    cli_h1("Importing bcbio-nextgen RNA-seq run")

    ## Run info ----------------------------------------------------------------
    uploadDir <- realpath(uploadDir)
    cli_dl(c(uploadDir = uploadDir))
    projectDir <- projectDir(uploadDir)
    cat_line()
    sampleDirs <- sampleDirs(uploadDir)
    cat_line()
    yamlFile <- file.path(projectDir, "project-summary.yaml")
    yaml <- import(yamlFile)
    assert(is.list(yaml))
    dataVersions <-
        importDataVersions(file.path(projectDir, "data_versions.csv"))
    assert(is(dataVersions, "DataFrame"))
    programVersions <-
        importProgramVersions(file.path(projectDir, "programs.txt"))
    assert(is(programVersions, "DataFrame"))
    log <- import(file.path(projectDir, "bcbio-nextgen.log"))
    ## This step enables our minimal dataset inside the package to pass checks.
    tryCatch(
        expr = assert(isCharacter(log)),
        error = function(e) {
            cli_alert_warning("'bcbio-nextgen.log' file is empty.")
        }
    )
    fastPipeline <- .isFastPipeline(log)
    if (isTRUE(fastPipeline)) {
        cli_text("Fast RNA-seq pipeline (fastrnaseq) detected.")
    }
    commandsLog <- import(file.path(projectDir, "bcbio-nextgen-commands.log"))
    ## This step enables our minimal dataset inside the package to pass checks.
    tryCatch(
        expr = assert(isCharacter(commandsLog)),
        error = function(e) {
            cli_alert_warning("'bcbio-nextgen-commands.log' file is empty.")
        }
    )

    ## Sequencing lanes --------------------------------------------------------
    lanes <- detectLanes(sampleDirs)
    assert(
        isInt(lanes) ||
        identical(lanes, integer())
    )

    ## Column data (samples) ---------------------------------------------------
    cli_h2("Sample metadata")
    ## Get the sample data.
    if (isString(sampleMetadataFile)) {
        ## Normalize path of local file.
        if (file.exists(sampleMetadataFile)) {
            sampleMetadataFile <- realpath(sampleMetadataFile)
        }
        ## User-defined metadata file.
        sampleData <- importSampleData(
            file = sampleMetadataFile,
            lanes = lanes,
            pipeline = "bcbio"
        )
    } else {
        ## Automatic metadata from YAML file.
        sampleData <- getSampleDataFromYAML(yaml)
    }
    assert(isSubset(rownames(sampleData), names(sampleDirs)))
    ## Subset the sample directories, if necessary.
    if (is.character(samples) || is.character(censorSamples)) {
        ## Matching against the YAML "description" input here.
        description <- as.character(sampleData[["description"]])
        assert(hasLength(description))
        if (is.character(samples)) {
            assert(isSubset(samples, description))
        } else {
            samples <- description
        }
        if (is.character(censorSamples)) {
            assert(isSubset(censorSamples, samples))
            samples <- setdiff(samples, censorSamples)
        }
        assert(isCharacter(samples))
        keep <- sampleData[["description"]] %in% samples
        sampleData <- sampleData[keep, , drop = FALSE]
    }
    samples <- rownames(sampleData)
    assert(
        ## Requiring at least 2 samples.
        length(samples) >= 2L,
        isSubset(samples, names(sampleDirs)),
        ## Check that name sanitization worked.
        validNames(samples)
    )
    if (length(samples) < length(sampleDirs)) {
        sampleDirs <- sampleDirs[samples]
        cli_alert(sprintf(
            fmt = "Loading a subset of samples: {.var %s}.",
            toString(basename(sampleDirs), width = 100L)
        ))
        allSamples <- FALSE
    } else {
        allSamples <- TRUE
    }
    ## Sample metrics. Note that sample metrics used for QC plots are not
    ## currently generated when using fast RNA-seq workflow. This depends upon
    ## MultiQC and aligned counts generated with STAR.
    colData <- getMetricsFromYAML(yaml)
    if (hasLength(colData)) {
        assert(
            areDisjointSets(colnames(colData), colnames(sampleData)),
            isSubset(rownames(sampleData), rownames(colData))
        )
        colData <- colData[rownames(sampleData), , drop = FALSE]
        colData <- cbind(colData, sampleData)
    } else {
        colData <- sampleData
    }
    assert(
        is(colData, "DataFrame"),
        identical(samples, rownames(colData))
    )

    ## Assays (counts) ---------------------------------------------------------
    cli_h2("Counts")
    assays <- SimpleList()
    ## Use tximport by default for transcript-aware callers. Otherwise, resort
    ## to loading the featureCounts aligned counts data. As of v0.3.22, we're
    ## alternatively slotting the aligned counts as "aligned" matrix when
    ## pseudoaligned counts are defined in the primary "counts" assay.
    if (caller %in% .tximportCallers) {
        cli_h3("tximport")
        tx2gene <- importTx2Gene(
            file = file.path(projectDir, "tx2gene.csv"),
            organism = organism,
            genomeBuild = genomeBuild,
            ensemblRelease = ensemblRelease
        )
        assert(is(tx2gene, "Tx2Gene"))
        if (level == "transcripts") {
            txOut <- TRUE
        } else {
            txOut <- FALSE
        }
        txi <- .tximport(
            sampleDirs = sampleDirs,
            type = caller,
            txOut = txOut,
            countsFromAbundance = countsFromAbundance,
            tx2gene = tx2gene
        )
        ## Raw counts. Length scaled by default (see `countsFromAbundance`).
        ## These counts are expected to be non-integer.
        assays[["counts"]] <- txi[["counts"]]
        ## Transcripts per million.
        assays[["tpm"]] <- txi[["abundance"]]
        ## Average transcript lengths.
        assays[["avgTxLength"]] <- txi[["length"]]
        if (
            identical(level, "genes") &&
            !isTRUE(fastPipeline) &&
            !isTRUE(fast)
        ) {
            cli_h3("featureCounts")
            assays[["aligned"]] <- .featureCounts(
                projectDir = projectDir,
                samples = samples,
                genes = rownames(txi[["counts"]])
            )
        }
    } else if (caller %in% .featureCountsCallers) {
        cli_h3("featureCounts")
        txi <- NULL
        countsFromAbundance <- "no"
        assert(identical(level, "genes"))
        cli_alert("Slotting aligned counts into primary {.fun counts} assay.")
        assays[["counts"]] <- .featureCounts(
            projectDir = projectDir,
            samples = samples
        )
    }
    assert(
        identical(names(assays)[[1L]], "counts"),
        identical(colnames(assays[[1L]]), rownames(colData))
    )

    ## Row data (genes/transcripts) --------------------------------------------
    cli_h2("Feature metadata")
    ## Annotation priority:
    ## 1. AnnotationHub.
    ##    - Requires `organism` to be declared.
    ##    - Ensure that Ensembl release and genome build match.
    ## 2. GTF/GFF file. Use the bcbio GTF if possible.
    ## 3. Fall back to slotting empty ranges. This is offered as support for
    ##    complex datasets (e.g. multiple organisms).
    if (isString(organism) && is.numeric(ensemblRelease)) {
        ## AnnotationHub (ensembldb).
        cli_alert("{.fun makeGRangesFromEnsembl}")
        rowRanges <- makeGRangesFromEnsembl(
            organism = organism,
            level = level,
            genomeBuild = genomeBuild,
            release = ensemblRelease
        )
    } else {
        ## GTF/GFF file.
        if (is.null(gffFile)) {
            ## Attempt to use bcbio GTF automatically.
            gffFile <- getGTFFileFromYAML(yaml)
        }
        if (!is.null(gffFile) && !isTRUE(fast)) {
            cli_alert("{.fun makeGRangesFromGFF}")
            gffFile <- realpath(gffFile)
            rowRanges <- makeGRangesFromGFF(file = gffFile, level = level)
        } else {
            cli_alert_warning("Slotting empty ranges into {.fun rowRanges}.")
            rowRanges <- emptyRanges(rownames(assays[[1L]]))
        }
    }
    assert(is(rowRanges, "GRanges"))
    ## Attempt to get genome build and Ensembl release if not declared. Note
    ## that these will remain NULL when using GTF file (see above).
    if (is.null(genomeBuild)) {
        genomeBuild <- metadata(rowRanges)[["genomeBuild"]]
    }
    if (is.null(ensemblRelease)) {
        ensemblRelease <- metadata(rowRanges)[["ensemblRelease"]]
    }

    ## Metadata ----------------------------------------------------------------
    ## Interesting groups.
    interestingGroups <- camelCase(interestingGroups)
    assert(isSubset(interestingGroups, colnames(colData)))
    ## Organism.
    ## Attempt to detect automatically if not declared by user.
    if (is.null(organism)) {
        organism <- tryCatch(
            expr = detectOrganism(rownames(assays[[1L]])),
            error = function(e) {
                warning(
                    "Failed to detect organism automatically.\n",
                    "Specify with 'organism' argument."
                )
            }
        )
    }
    metadata <- list(
        allSamples = allSamples,
        bcbioCommandsLog = commandsLog,
        bcbioLog = log,
        call = standardizeCall(),
        caller = caller,
        countsFromAbundance = countsFromAbundance,
        dataVersions = dataVersions,
        ensemblRelease = as.integer(ensemblRelease),
        fast = fast,
        genomeBuild = as.character(genomeBuild),
        gffFile = as.character(gffFile),
        interestingGroups = interestingGroups,
        lanes = lanes,
        level = level,
        organism = as.character(organism),
        programVersions = programVersions,
        projectDir = projectDir,
        runDate = runDate(projectDir),
        sampleDirs = sampleDirs,
        sampleMetadataFile = as.character(sampleMetadataFile),
        tx2gene = tx2gene,
        uploadDir = uploadDir,
        version = .version,
        yaml = yaml
    )

    ## Make bcbioRNASeq object -------------------------------------------------
    rse <- makeSummarizedExperiment(
        assays = assays,
        rowRanges = rowRanges,
        colData = colData,
        metadata = metadata,
        transgeneNames = transgeneNames,
        spikeNames = spikeNames
    )
    bcb <- new(Class = "bcbioRNASeq", rse)

    ## DESeq2 ------------------------------------------------------------------
    if (level == "genes" && !isTRUE(fast)) {
        cli_h2("DESeq2 normalizations")
        dds <- as(bcb, "DESeqDataSet")
        ## Calculate size factors for normalized counts.
        cli_alert("{.fun estimateSizeFactors}")
        dds <- estimateSizeFactors(dds)
        assays(bcb)[["normalized"]] <- counts(dds, normalized = TRUE)
        ## Skip full DESeq2 calculations (for internal bcbio test data).
        if (.dataHasVariation(dds)) {
            cli_alert("{.fun DESeq}")
            dds <- DESeq(dds)
            cli_alert("{.fun varianceStabilizingTransformation}")
            assays(bcb)[["vst"]] <-
                assay(varianceStabilizingTransformation(dds))
            ## Note that rlog is no longer allowed here.
            ## Run it manually on a coerced DESeqDataSet instead.
        } else {
            ## nocov start
            ## This step is covered by bcbio pipeline tests.
            cli_alert_warning(paste(
                "{.fun varianceStabilizingTransformation}:",
                "Skipping transformation because data has no variation."
            ))
            ## nocov end
        }
        ## Calculate FPKM.
        ## Skip this step if we've slotted empty ranges.
        if (length(unique(width(rowRanges(dds)))) > 1L) {
            cli_alert("{.fun fpkm}")
            assays(bcb)[["fpkm"]] <- fpkm(dds)
        } else {
            cli_alert_warning(paste(
                "{.fun fpkm}: Skipping FPKM calculation because",
                "{.fun rowRanges} is empty."
            ))
        }
    }

    ## Return ------------------------------------------------------------------
    assert(hasValidDimnames(bcb))
    validObject(bcb)
    cat_line()
    cli_alert_success("bcbio RNA-seq run imported successfully.")
    bcb
}
