#' Heatmaps
#'
#' These functions are wrappers to [pheatmap()] that have been optimized to work
#' with a [bcbioRnaDataSet] run object. They also depend on a [DESeqTransform]
#' object containing transformed counts, which are ideal for heatmap plots.
#'
#' `plot_correlation_heatmap()` calculates a correlation matrix based on gene
#' expression per sample. By default, this function processes all gene counts
#' per sample to calculate the corrlation matrix. This behavior can be overrided
#' with the input of `gene` identifier vector. In this case, only the expression
#' of the desired genes will be used to calculate the correlation matrix.
#'
#' `plot_gene_heatmap()` facilities heatmap plotting of a specified set of
#' genes. The function by default performs row- and column-wise hierarhical
#' clustering using the Ward method, but this behavior can be overrided by
#' setting `cluster_rows` or `cluster_cols` to `FALSE`. When column clustering
#' is disabled, the function sorts columns by the interesting groups
#' (`intgroup`) specified in the [bcbioRnaDataSet] and then the sample names.
#'
#' `plot_deg_heatmap()` is a simplified version of `plot_gene_heatmap()` that is
#' optimized for handling a [DESeqResults] object rather a gene vector. All of
#' the optional parameters for `plot_gene_heatmap()` are also available to this
#' function.
#'
#' @seealso
#' - [cor()].
#' - [pheatmap()].
#'
#' @rdname heatmaps
#' @author Michael Steinbaugh
#'
#' @param bcb [bcbioRnaDataSet].
#' @param dt [DESeqTransform]. Transformed counts generated by [rlog()]
#'   (**recommended**) or [vst()] on a [DESeqDataSet] are supported.
#' @param genes Character vector of specific gene identifiers to plot.
#' @param intgroup Interesting groups to label with bars above heatmap. If
#'   `NULL`, defaults to `intgroup` defined in [bcbioRnaDataSet].
#' @param annotation Optional alternative annotation to use. Useful when
#'   plotting more than one column.
#' @param title Optional text to include in plot title.
#' @param method Correlation coefficient (or covariance) to be computed.
#'   Defaults to `pearson` but `spearman` can also be used.
#' @param clustering_method Clustering method. Accepts the same values as
#'   [hclust()].
#' @param ... Passthrough parameters to [pheatmap()].
#'
#' @return [pheatmap()] object.
#' @export
plot_correlation_heatmap <- function(
    bcb,
    dt,
    genes = NULL,
    intgroup = NULL,
    annotation = NULL,
    title = NULL,
    method = "pearson",
    clustering_method = "ward.D2",
    ...) {
    run <- metadata(bcb)
    check_run(run)
    check_dt(dt)

    if (!method %in% c("pearson", "spearman")) {
        stop("Supported methods: pearson, spearman")
    }

    # Override the default `intgroup` set in run, if desired
    if (is.null(intgroup)) {
        intgroup <- run$intgroup
    }

    # Obtain the metadata annotations, if not specified
    if (is.null(annotation)) {
        annotation <- select_intgroup_coldata(dt, intgroup)
    }

    # Set heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- paste("correlation",
                      method,
                      deparse(substitute(dt)),
                      sep = label_sep)
    }

    # Get counts and annotations from [DESeqTransform]
    counts <- assay(dt)

    # Subset counts matrix by input genes, if desired
    if (!is.null(genes)) {
        counts <- counts[genes, ]
    }

    counts %>%
        cor(method = method) %>%
        pheatmap(
            annotation = annotation,
            clustering_method = clustering_method,
            clustering_distance_rows = "correlation",
            clustering_distance_cols = "correlation",
            main = main,
            show_colnames = FALSE,
            show_rownames = TRUE,
            ...)
}



#' @rdname heatmaps
#' @param cluster_rows Whether rows should be clustered using [hclust()].
#' @param cluster_cols Whether columns should be clustered using [hclust()].
#' @param scale Character indicating if the values should be centered and scaled
#'   in either the `row` direction, `column` direction, or `none`.
#' @export
plot_gene_heatmap <- function(
    bcb,
    dt,
    genes,
    intgroup = NULL,
    annotation = NULL,
    title = NULL,
    clustering_method = "ward.D2",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    scale = "row",
    ...) {
    run <- metadata(bcb)
    check_run(run)
    check_dt(dt)

    # Override the default `intgroup` set in run, if desired
    if (is.null(intgroup)) {
        intgroup <- run$intgroup
    }

    # Obtain the metadata annotations, unless specified
    if (is.null(annotation)) {
        annotation <- select_intgroup_coldata(dt, intgroup)
    }

    # Set heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- deparse(substitute(dt))
    }

    # Subset the DESeqTransform (e.g. rlog counts)
    counts <- dt %>% assay %>% .[genes, ]

    # [fix] Add an option to override this behavior?
    # If `cluster_cols = FALSE`, sort by `intgroup` then `description`
    if (!isTRUE(cluster_cols)) {
        sorted_cols <- colData(dt) %>%
            as.data.frame %>%
            arrange(!!!syms(c(intgroup, "description"))) %>%
            tidy_select(!!sym("description")) %>% .[[1]]
        counts <- counts[, sorted_cols]
    }

    # Change rownames to readable external gene names
    if (nrow(counts) <= 100) {
        show_rownames <- TRUE
        gene_names <- gene_level_annotations(run) %>%
            tidy_select(!!!syms(c("ensembl_gene_id", "external_gene_name"))) %>%
            set_rownames(.$ensembl_gene_id)
        rownames(counts) <- gene_names[rownames(counts), "external_gene_name"]
    } else {
        show_rownames <- FALSE
    }

    pheatmap(counts,
             annotation = annotation[colnames(counts),,drop=FALSE],
             cluster_cols = cluster_cols,
             cluster_rows = cluster_rows,
             clustering_method = clustering_method,
             main = main,
             scale = scale,
             show_colnames = TRUE,
             show_rownames = show_rownames,
             ...)
}



#' @rdname heatmaps
#' @param res [DESeqResults].
#' @export
plot_deg_heatmap <- function(bcb, dt, res, ...) {
    run <- metadata(bcb)
    check_run(run)
    check_dt(dt)
    check_res(res)

    # Set the default title
    if (is.null(title)) {
        title <- paste(
            deparse(substitute(dt)),
            deparse(substitute(res)),
            res_contrast_name(res),
            sep = label_sep)
    }

    # Filter gene IDs by alpha and LFC from [DESeqResults]
    # [fix] alpha <- run$alpha
    alpha <- run$alpha
    lfc <- run$lfc

    genes <- res %>%
        as.data.frame %>%
        rownames_to_column("ensembl_gene_id") %>%
        filter(.data$padj < alpha,
               .data$log2FoldChange > lfc | .data$log2FoldChange < -lfc) %>%
        tidy_select(!!sym("ensembl_gene_id")) %>% .[[1]]

    plot_gene_heatmap(bcb, dt, genes = genes, ...)
}
