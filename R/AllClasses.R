#' bcbioRNASeq Class
#'
#' S4 class containing RNA-seq counts and metadata generated by
#' [bcbio](https://bcbio-nextgen.readthedocs.org).
#'
#' `bcbioRNASeq` extends `RangedSummarizedExperiment` and is designed to store
#' an RNA-seq analysis. This class contains raw read counts and length-scaled
#' transcripts per million (TPM) generated by [tximport::tximport()]. Counts can
#' be loaded at gene (default) or transcript level.
#'
#' DESeq2 is run automatically when [loadRNASeq()] is called, and variance
#' stabilized counts are slotted into [assays()]
#'
#' The [metadata()] accessor contains:
#'
#' - Sample quality control metrics.
#' - Ensembl annotations.
#' - Server run paths.
#' - R session information (e.g. [utils::sessionInfo()]).
#'
#' @author Lorena Pantano, Michael Steinbaugh
#' @export
#'
#' @seealso
#' - [loadRNASeq()].
#' - [SummarizedExperiment::SummarizedExperiment()].
#' - `.S4methods(class = "bcbioRNASeq")`.
#'
#' @examples
#' uploadDir <- system.file("extdata/bcbio", package = "bcbioRNASeq")
#'
#' bcb <- loadRNASeq(uploadDir)
#' print(bcb)
#'
#' # Check validity
#' validObject(bcb)
bcbioRNASeq <- setClass(
    Class = "bcbioRNASeq",
    contains = "RangedSummarizedExperiment"
)



# Validity =====================================================================
setValidity(
    "bcbioRNASeq",
    function(object) {
        assert_is_all_of(object, "SummarizedExperiment")
        assert_has_dimnames(object)

        # Required assays (count matrices)
        # Note that `rlog` and `vst` DESeqTransform objects are optional
        assert_is_subset(
            x = c("raw", "tpm", "length", "dds"),
            y = assayNames(object)
        )

        # rowRanges must contain genomic ranges, if set
        if (!is.null(rowRanges(object))) {
            assert_is_all_of(rowRanges(object), "GRanges")
        }

        # rowData must contain ensgene and symbol, if set
        if (!is.null(rowData(object))) {
            assert_is_subset(
                x = c("ensgene", "symbol"),
                y = colnames(rowData(object))
            )
        }

        # Column data must contain factors
        colDataFactor <- vapply(
            X = colData(object),
            FUN = is.factor,
            FUN.VALUE = logical(1L),
            USE.NAMES = TRUE
        )
        if (any(!colDataFactor)) {
            abort(paste(
                paste(
                    "Non-factor colData columns:",
                    toString(names(colDataFactor[!colDataFactor]))
                ),
                updateMsg,
                sep = "\n"
            ))
        }

        # Metadata
        requiredMetadata <- list(
            "version" = "package_version",
            "uploadDir" = "character",
            "sampleDirs" = "character",
            "projectDir" = "character",
            "template" = "character",
            "runDate" = "Date",
            "level" = "character",
            "caller" = "character",
            "interestingGroups" = "character",
            "isSpike" = c("character", "NULL"),
            "organism" = "character",
            "genomeBuild" = "character",
            "ensemblVersion" = c("integer", "NULL"),
            "annotationHub" = c("list", "NULL"),
            "tx2gene" = "data.frame",
            "lanes" = "integer",
            "yaml" = "list",
            "metrics" = "data.frame",
            "sampleMetadataFile" = c("character", "NULL"),
            "dataVersions" = "tbl_df",
            "programVersions" = "tbl_df",
            "bcbioLog" = "character",
            "bcbioCommandsLog" = "character",
            "allSamples" = "logical",
            "design" = "formula",
            "date" = "Date",
            "wd" = "character",
            "utilsSessionInfo" = "sessionInfo",
            "devtoolsSessionInfo" = "session_info",
            "unannotatedRows" = "character"
        )

        # Inform the user about renamed metadata slots
        legacyMetadata <- c(
            "gtf",
            "missingGenes",
            "programs"
        )
        intersect <- intersect(names(metadata(object)), legacyMetadata)
        if (length(intersect)) {
            abort(paste(
                paste(
                    "Legacy metadata slots:",
                    toString(sort(intersect))
                ),
                updateMsg,
                sep = "\n"
            ))
        }

        # Integrity check the classes of required metadata
        classChecks <- invisible(vapply(
            X = seq_along(requiredMetadata),
            FUN = function(a) {
                name <- names(requiredMetadata)[[a]]
                actual <- class(metadata(object)[[name]])
                expected <- requiredMetadata[[a]]
                if (!length(intersect(expected, actual))) {
                    warn(paste(
                        name, "is not", toString(expected)
                    ))
                    FALSE
                } else {
                    TRUE
                }
            },
            FUN.VALUE = logical(1L),
            USE.NAMES = FALSE
        ))
        if (!all(classChecks)) {
            abort(paste(
                "Metadata class checks failed.", updateMsg, sep = "\n"
            ))
        }

        # Metrics
        metrics <- metadata(object)[["metrics"]]
        assert_are_identical(colnames(object), rownames(metrics))
        assert_are_disjoint_sets(colnames(metrics), legacyMetricsCols)

        # Transcript to gene mappings
        tx2gene <- metadata(object)[["tx2gene"]]
        assertIsTx2gene(tx2gene)

        TRUE
    }
)
