#' Correlation heatmap
#'
#' This function calculates a correlation matrix based on gene expression per
#' sample. By default, this function processes all gene counts per sample to
#' calculate the corrlation matrix. This behavior can be overrided with the
#' input of `gene` identifier vector. In this case, only the expression of the
#' desired genes will be used to calculate the correlation matrix.
#'
#' @author Michael Steinbaugh
#'
#' @param bcb [bcbioRNADataSet].
#' @param transform String specifying [rlog] (**recommended**) or [vst]
#'   [DESeqTransform] slotted inside the [bcbioRNADataSet].
#' @param method Correlation coefficient (or covariance) to be computed.
#'   Defaults to `pearson` but `spearman` can also be used. Consult the
#'   [stats::cor()] documentation for more information.
#' @param clustering_method Hierarchical clustering method. Accepts the same
#'   values as [stats::hclust()].
#' @param samples *Optional*. Character vector of specific samples.
#' @param genes *Optional*. Character vector of specific gene identifiers to
#'   plot.
#' @param interesting_groups *Optional*. Interesting groups to label with bars
#'   above heatmap. If `NULL`, defaults to `interesting_groups` defined in the
#'   [bcbioRNADataSet].
#' @param annotation *Optional*. Alternative annotation to use. Useful when
#'   plotting more than one column.
#' @param title *Optional*. Text to include in plot title.
#' @param ... Additional arguments, passed to [pheatmap::pheatmap()].
#'
#' @return Heatmap plot [pheatmap::pheatmap()].
#' @examples
#' data(dummy)
#' plot_correlation_heatmap(bcb)
#' @export
#'
#' @seealso [stats::cor()]
plot_correlation_heatmap <- function(
    bcb,
    transform = "rlog",
    method = "pearson",
    clustering_method = "ward.D2",
    genes = NULL,
    samples = NULL,
    interesting_groups = NULL,
    annotation = NULL,
    title = NULL,
    ...) {
    # Check for supported correlation method
    if (!method %in% c("pearson", "spearman")) {
        stop("Supported methods: pearson, spearman")
    }

    # Interesting groups
    if (is.null(interesting_groups)) {
        interesting_groups <- metadata(bcb)[["interesting_groups"]]
    }

    # Per sample annotations of interest
    if (is.null(annotation)) {
        annotation <- colData(bcb) %>%
            .[, interesting_groups, drop = FALSE] %>%
            as.data.frame
    }

    # Set heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- paste(method, "correlation")
    }

    # Transformed counts
    if (!transform %in% c("rlog", "vst")) {
        stop("DESeqTransform must be rlog or vst")
    }
    # Get count matrix from [DESeqTransform]
    counts <- assays(bcb)[[transform]] %>% assay

    # Subset counts matrix by input genes, if desired
    if (!is.null(genes)) {
        counts <- counts[genes, ]
    }

    # Subset count matrix by input samples, if desired
    if (!is.null(samples)) {
        counts <- counts[, samples]
        annotation <- annotation[samples, ]
    }

    counts %>%
        cor(method = method) %>%
        pheatmap(
            annotation = annotation,
            clustering_method = clustering_method,
            clustering_distance_rows = "correlation",
            clustering_distance_cols = "correlation",
            main = main,
            show_colnames = FALSE,
            show_rownames = TRUE,
            ...)
}



#' Gene heatmap
#'
#' These functions facilitate heatmap plotting of a specified set of genes. By
#' default, row- and column-wise hierarchical clustering is performed using the
#' Ward method, but this behavior can be overrided by setting `cluster_rows` or
#' `cluster_cols` to `FALSE`. When column clustering is disabled, the columns
#' are sorted by the interesting groups (`interesting_groups`) specified in the
#' [bcbioRNADataSet] and then the sample names.
#'
#' @author Michael Steinbaugh
#'
#' @param bcb [bcbioRNADataSet].
#' @param dt [DESeqTransform]. Transformed counts generated by [rlog()]
#'   (**recommended**) or [vst()] on a [DESeqDataSet] are supported.
#' @param genes Character vector of specific gene identifiers to plot.
#' @param clustering_method Hierarchical clustering method. Accepts the same
#'   values as [stats::hclust()].
#' @param cluster_rows Use hierarchical clustering to arrange rows.
#' @param cluster_cols Use hierarchical clustering to arrange columns.
#' @param scale Character indicating if the values should be centered and scaled
#'   in either the `row` direction, `column` direction, or `none`.
#' @param interesting_groups *Optional*. Interesting groups to label with bars
#'   above heatmap. If `NULL`, defaults to `interesting_groups` defined in the
#'   [bcbioRNADataSet].
#' @param annotation *Optional*. Alternative annotation to use. Useful when
#'   plotting more than one column.
#' @param title *Optional*. Text to include in plot title.
#' @param ... Additional arguments.
#'
#' @export
#'
#' @seealso [pheatmap::pheatmap()].
plot_gene_heatmap <- function(
    bcb,
    dt = NULL,
    genes,
    clustering_method = "ward.D2",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    scale = "row",
    interesting_groups = NULL,
    annotation = NULL,
    title = NULL,
    ...) {
    # Interesting groups
    if (is.null(interesting_groups)) {
        interesting_groups <- metadata(bcb)[["interesting_groups"]]
    }

    # Heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- "gene heatmap"
    }

    # Transformed counts
    if (is.null(dt)) {
        # If NULL, use rlog counts from bcbioRNADataSet
        dt <- assays(bcb)[["rlog"]]
    }
    counts <- assay(dt) %>% .[genes, ]

    # `cluster_cols = FALSE`: Turn off sample hierarchical clustering and sort
    # by interesting groups then sample name, if preferred
    if (!isTRUE(cluster_cols)) {
        sorted_cols <- colData(bcb) %>%
            as.data.frame %>%
            arrange(!!!syms(c(interesting_groups, "description"))) %>%
            pull("description")
        counts <- counts[, sorted_cols]
    }

    # Change rownames to readable external gene names
    if (nrow(counts) <= 100L) {
        show_rownames <- TRUE
        gene2symbol <- gene2symbol(bcb)
        rownames(counts) <- gene2symbol[rownames(counts), "symbol"]
    } else {
        show_rownames <- FALSE
    }

    # Per sample annotations of interest
    if (is.null(annotation)) {
        annotation <- colData(bcb) %>%
            as.data.frame %>%
            .[colnames(counts), interesting_groups, drop = FALSE]
    }

    pheatmap(counts,
             annotation = annotation,
             cluster_cols = cluster_cols,
             cluster_rows = cluster_rows,
             clustering_method = clustering_method,
             main = main,
             scale = scale,
             show_colnames = TRUE,
             show_rownames = show_rownames,
             ...)
}



#' @rdname plot_gene_heatmap
#'
#' @details [plot_deg_heatmap()] is a simplified version of
#'   [plot_gene_heatmap()] that is optimized for handling a [DESeqResults]
#'   object rather a gene vector. All of the optional parameters for
#'   [plot_gene_heatmap()] are also available to this function.
#'
#' @param res [DESeqResults].
#' @param lfc [log2] fold change ratio.
#'
#' @export
plot_deg_heatmap <- function(
    bcb,
    dt = NULL,
    res,
    lfc,
    title = NULL,
    ...) {
    if (is.null(title)) {
        title <- "differentially expressed genes"
    }
    # Filter gene IDs by alpha and LFC from [DESeqResults]
    alpha <- metadata(res)[["alpha"]]
    genes <- res %>%
        as.data.frame %>%
        rownames_to_column("ensgene") %>%
        filter(.data[["padj"]] < alpha,
               .data[["log2FoldChange"]] > lfc |
                   .data[["log2FoldChange"]] < -lfc) %>%
        pull("ensgene") %>%
        sort

    plot_gene_heatmap(bcb, dt = dt, genes = genes, title = title, ...)
}
