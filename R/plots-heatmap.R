#' Heatmaps
#'
#' These functions are wrappers to [pheatmap()] that have been optimized to work
#' with a [bcbioRnaDataSet] run object. They also depend on a [DESeqTransform]
#' object containing transformed counts, which are ideal for heatmap plots.
#'
#' `plot_correlation_heatmap()` calculates a correlation matrix based on gene
#' expression per sample. By default, this function processes all gene counts
#' per sample to calculate the corrlation matrix. This behavior can be overrided
#' with the input of `gene` identifier vector. In this case, only the expression
#' of the desired genes will be used to calculate the correlation matrix.
#'
#' `plot_gene_heatmap()` facilities heatmap plotting of a specified set of
#' genes. The function by default performs row- and column-wise hierarhical
#' clustering using the Ward method, but this behavior can be overrided by
#' setting `cluster_rows` or `cluster_cols` to `FALSE`. When column clustering
#' is disabled, the function sorts columns by the interesting groups
#' (`interesting_groups`) specified in the [bcbioRnaDataSet] and then the sample names.
#'
#' `plot_deg_heatmap()` is a simplified version of `plot_gene_heatmap()` that is
#' optimized for handling a [DESeqResults] object rather a gene vector. All of
#' the optional parameters for `plot_gene_heatmap()` are also available to this
#' function.
#'
#' @seealso
#' - [cor()].
#' - [pheatmap()].
#'
#' @rdname plots-heatmap
#' @author Michael Steinbaugh
#'
#' @param bcb [bcbioRnaDataSet].
#' @param dt [DESeqTransform]. Transformed counts generated by [rlog()]
#'   (**recommended**) or [vst()] on a [DESeqDataSet] are supported.
#' @param genes Character vector of specific gene identifiers to plot.
#' @param interesting_groups Interesting groups to label with bars above heatmap. If
#'   `NULL`, defaults to `interesting_groups` defined in [bcbioRnaDataSet].
#' @param annotation Optional alternative annotation to use. Useful when
#'   plotting more than one column.
#' @param title Optional text to include in plot title.
#' @param method Correlation coefficient (or covariance) to be computed.
#'   Defaults to `pearson` but `spearman` can also be used. Consult the [cor()]
#'   documentation for more information.
#' @param clustering_method Clustering method. Accepts the same values as
#'   [hclust()].
#' @param ... Passthrough parameters to [pheatmap()].
#'
#' @return [pheatmap()] object.
#' @export
plot_correlation_heatmap <- function(
    bcb,
    dt,
    genes = NULL,
    interesting_groups = NULL,
    annotation = NULL,
    title = NULL,
    method = "pearson",
    clustering_method = "ward.D2",
    ...) {
    # Check for supported correlation method
    if (!method %in% c("pearson", "spearman")) {
        stop("Supported methods: pearson, spearman")
    }

    # Interesting groups
    if (is.null(interesting_groups)) {
        interesting_groups <- metadata(bcb)[["interesting_groups"]]
    }

    # Per sample annotations of interest
    if (is.null(annotation)) {
        annotation <- colData(bcb)[, interesting_groups, drop = FALSE] %>% as.data.frame
    }

    # Set heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- paste(method, "correlation")
    }

    # Get counts and annotations from [DESeqTransform]
    counts <- assay(dt)

    # Subset counts matrix by input genes, if desired
    if (!is.null(genes)) {
        counts <- counts[genes, ]
    }

    counts %>%
        cor(method = method) %>%
        pheatmap(
            annotation = annotation,
            clustering_method = clustering_method,
            clustering_distance_rows = "correlation",
            clustering_distance_cols = "correlation",
            main = main,
            show_colnames = FALSE,
            show_rownames = TRUE,
            ...)
}



#' @rdname plots-heatmap
#' @param cluster_rows Whether rows should be clustered using [hclust()].
#' @param cluster_cols Whether columns should be clustered using [hclust()].
#' @param scale Character indicating if the values should be centered and scaled
#'   in either the `row` direction, `column` direction, or `none`.
#' @export
plot_gene_heatmap <- function(
    bcb,
    dt,
    genes,
    interesting_groups = NULL,
    annotation = NULL,
    title = NULL,
    clustering_method = "ward.D2",
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    scale = "row",
    ...) {
    # Interesting groups
    if (is.null(interesting_groups)) {
        interesting_groups <- metadata(bcb)[["interesting_groups"]]
    }

    # Heatmap title (`main` parameter)
    if (!is.null(title)) {
        main <- title
    } else {
        main <- "gene heatmap"
    }

    # Subset the DESeqTransform matrix (e.g. rlog counts)
    counts <- dt %>%
        assay %>%
        .[genes, ]

    # `cluster_cols = FALSE`: Turn off sample hierarchical clustering and sort
    # by interesting groups then sample name, if preferred
    if (!isTRUE(cluster_cols)) {
        sorted_cols <- colData(dt) %>%
            as.data.frame %>%
            arrange(!!!syms(c(interesting_groups, "description"))) %>%
            pull("description")
        counts <- counts[, sorted_cols]
    }

    # Change rownames to readable external gene names
    if (nrow(counts) <= 100L) {
        show_rownames <- TRUE
        gene2symbol <- gene2symbol(bcb)
        rownames(counts) <- gene2symbol[rownames(counts), "symbol"]
    } else {
        show_rownames <- FALSE
    }

    # Per sample annotations of interest
    if (is.null(annotation)) {
        annotation <- colData(bcb) %>%
            as.data.frame %>%
            .[colnames(counts), interesting_groups, drop = FALSE]
    }

    pheatmap(counts,
             annotation = annotation,
             cluster_cols = cluster_cols,
             cluster_rows = cluster_rows,
             clustering_method = clustering_method,
             main = main,
             scale = scale,
             show_colnames = TRUE,
             show_rownames = show_rownames,
             ...)
}



# TODO Add option to slot lfc into [bcbioRnaDataSet]
#' @rdname plots-heatmap
#' @param res [DESeqResults].
#' @param lfc [log2] fold change ratio.
#' @export
plot_deg_heatmap <- function(bcb, dt, res, lfc = 1L, title = NULL, ...) {
    if (is.null(title)) {
        title <- "differentially expressed genes"
    }
    # Filter gene IDs by alpha and LFC from [DESeqResults]
    alpha <- metadata(res)[["alpha"]]
    genes <- res %>%
        as.data.frame %>%
        rownames_to_column("ensgene") %>%
        filter(.data[["padj"]] < alpha,
               .data[["log2FoldChange"]] > lfc | .data[["log2FoldChange"]] < -lfc) %>%
        pull("ensgene") %>% sort
    plot_gene_heatmap(bcb, dt, genes = genes, title = title, ...)
}
